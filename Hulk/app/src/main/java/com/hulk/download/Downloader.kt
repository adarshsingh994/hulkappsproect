package com.hulk.download

import android.app.DownloadManager
import android.content.Context
import android.database.sqlite.SQLiteException
import android.net.Uri
import android.os.Build
import android.os.Environment
import android.webkit.MimeTypeMap
import com.hulk.Util.logd
import com.hulk.broadcast_receiver.DownloadManagerBroadcastReceiver
import java.io.File
import java.util.*
import kotlin.collections.HashMap


/**
 * A helper class to download files using [DownloadManager]
 *
 * @param listener a callback to listen for download updated
 * @param downloadManager android's [DownloadManager] class
 */
class Downloader(
    private val listener: DownloaderListener,
    private val downloadManager: DownloadManager
) {
    private var dmBroadcastReceiver: DownloadManagerBroadcastReceiver? = null
    private var idUrlMap = HashMap<Long, String>()

    /**
     * Enum class representing the state of download
     */
    enum class State {
        /**
         * Represents the success state of download
         */
        SUCCESS,

        /**
         * Represents the failed state of download
         */
        FAILED,

        /**
         * Represents the paused state of download
         */
        PAUSED,

        /**
         * Represents the pending state of download
         */
        PENDING,

        /**
         * Represents the running state of download
         */
        RUNNING
    }

    interface DownloaderListener {
        fun onFileDownloaded(url : String, path : String?)
        fun onFileDownloadStarted(url : String)
        fun onFileDownloadError(url : String)
        fun onFileDownloadRunning(url : String)
        fun onFileDownloadPending(url: String)
        fun onFileDownloadPaused(url: String)
        fun onFileAlreadyDownloaded()
    }

    // Start file download
    fun startDownloadingFile(context : Context, url : String, extension : String?) {
        val title = UUID.randomUUID().toString()
        val uri = Uri.parse(url)
        val request = DownloadManager.Request(uri)
        request.setTitle(title)
        request.setDescription("Downloading")
        request.setMimeType(getMimetypeFromExtension(extension ?: "mp4")) // Default to mp4
        request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_HIDDEN)
        request.setDestinationInExternalFilesDir(context, Environment.DIRECTORY_MOVIES, "${File.separator}$title.$extension")
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.R)
            request.allowScanningByMediaScanner()
        val id = downloadManager.enqueue(request)
        idUrlMap[id] = url
        listener.onFileDownloadStarted(url)
    }


    /**
     * This function request {@DownloadManager} for the state of download task represented by the id.
     *
     * @param id A @Long type id generated by {@DownloadManager) which uniquely identifies the downloading task.
     * @return The {@State} of download task specified by the provided id.
     */
    private fun getDownloadingState(id: Long): Int {
        val query = DownloadManager.Query().setFilterById(id)
        val cursor = downloadManager.query(query)
        try{
            cursor?.let {
                if(cursor.moveToFirst()){
                    val columnDownloadStatus = cursor.getColumnIndex(DownloadManager.COLUMN_STATUS)
                    val status = cursor.getInt(columnDownloadStatus)
                    cursor.close()
                    return status
                }
            }
        }catch (e: SQLiteException){
            return DownloadManager.STATUS_FAILED
        }finally {
            cursor.close()
        }
        return DownloadManager.STATUS_FAILED
    }

    private fun getDownloadedPath(id: Long): String? {
        val query = DownloadManager.Query().setFilterById(id)
        val cursor = downloadManager.query(query)
        try{
            cursor?.let {
                if(cursor.moveToFirst()){
                    val localUriIndex = cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI)
                    val localUri = cursor.getString(localUriIndex)
                    "Local uri: $localUri".logd("LJGSGNSLNSLGNLGNSLGN")
                    cursor.close()
                    return localUri
                }
            }
        }catch (e: SQLiteException){
            return null
        }finally {
            cursor.close()
        }
        return null
    }

    /**
     * Returns [DownloadManagerBroadcastReceiver]
     */
    @Throws(KotlinNullPointerException::class)
    fun getBroadcastReceiver(): DownloadManagerBroadcastReceiver {
        if (dmBroadcastReceiver == null) {
            dmBroadcastReceiver = DownloadManagerBroadcastReceiver(object :
                DownloadManagerBroadcastReceiver.DownloadManagerBroadcastListener {
                override fun onDownloadStatusChanged(id: Long) {
                    when (getDownloadingState(id)) {
                        DownloadManager.STATUS_SUCCESSFUL -> {
                            idUrlMap[id]?.let{
                                listener.onFileDownloaded(it, getDownloadedPath(id))
                            }
                        }
                        DownloadManager.STATUS_PAUSED, DownloadManager.STATUS_PENDING, DownloadManager.STATUS_RUNNING -> {
                            idUrlMap[id]?.let {
                                listener.onFileDownloadRunning(it)
                            }
                        }
                        DownloadManager.STATUS_FAILED -> {
                            idUrlMap[id]?.let{
                                listener.onFileDownloadError(it)
                            }
                        }
                    }
                }
            })
        }

        return dmBroadcastReceiver!!
    }

    private fun getMimetypeFromExtension(extension: String?) : String{
        val map = MimeTypeMap.getSingleton()
        val mimeType = map.getMimeTypeFromExtension(extension)!!
        return mimeType
    }
}